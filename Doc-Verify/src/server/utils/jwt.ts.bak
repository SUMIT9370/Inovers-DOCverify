import jwt from 'jsonwebtoken';

interface TokenPayload {
  userId: string;
  userType: string;
  iat?: number;
  exp?: number;
}

export class TokenService {
  private static readonly JWT_SECRET = process.env.JWT_SECRET ?? '';
  private static readonly JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET ?? '';
  private static readonly JWT_EXPIRY = process.env.JWT_EXPIRY ?? '1h';
  private static readonly JWT_REFRESH_EXPIRY = process.env.JWT_REFRESH_EXPIRY ?? '7d';

  static validateSecrets(): void {
    if (!process.env.JWT_SECRET || !process.env.JWT_REFRESH_SECRET) {
      throw new Error('JWT secrets must be configured in environment variables');
    }
  }

  static generateAccessToken(payload: { userId: string; userType: string }): string {
    this.validateSecrets();
    return jwt.sign(payload, this.JWT_SECRET, {
      expiresIn: this.JWT_EXPIRY
    });
  }

  static generateRefreshToken(payload: { userId: string; userType: string }): string {
    this.validateSecrets();
    return jwt.sign(payload, this.JWT_REFRESH_SECRET, {
      expiresIn: this.JWT_REFRESH_EXPIRY
    });
  }

  static verifyAccessToken(token: string): CustomJwtPayload {
    this.validateSecrets();
    try {
      const decoded = jwt.verify(token, this.JWT_SECRET) as CustomJwtPayload;
      if (!decoded.userId || !decoded.userType) {
        throw new Error('Invalid token payload');
      }
      return decoded;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw error;
      }
      throw new Error('Invalid token');
    }
  }

  static verifyRefreshToken(token: string): CustomJwtPayload {
    this.validateSecrets();
    try {
      const decoded = jwt.verify(token, this.JWT_REFRESH_SECRET) as CustomJwtPayload;
      if (!decoded.userId || !decoded.userType) {
        throw new Error('Invalid token payload');
      }
      return decoded;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw error;
      }
      throw new Error('Invalid refresh token');
    }
  }

  static isTokenExpired(decodedToken: CustomJwtPayload): boolean {
    const exp = decodedToken.exp;
    if (!exp) return true;
    return Date.now() >= exp * 1000;
  }

  static isTokenExpiringSoon(decodedToken: CustomJwtPayload, thresholdSeconds = 300): boolean {
    const exp = decodedToken.exp;
    if (!exp) return true;
    return (exp * 1000) - Date.now() < thresholdSeconds * 1000;
  }
}
